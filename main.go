package main

import (
	"fmt"
	"regexp"

	"github.com/alextanhongpin/pkg/gen"
	"github.com/dave/jennifer/jen"
	. "github.com/dave/jennifer/jen"
)

var (
	tagRe *regexp.Regexp
)

func init() {
	tagRe = regexp.MustCompile(`access:"([rw,-]+)"`)
}

func main() {
	gen.New(generateStructFromFields)
}

func generateStructFromFields(opt gen.Option) error {
	var (
		pkgName    = opt.PkgName
		pkgPath    = opt.PkgPath
		out        = opt.Out
		structName = opt.StructName
		fields     = opt.Fields
	)
	f := NewFile(pkgName) // e.g. main
	f.PackageComment(fmt.Sprintf("Code generated by %s, DO NOT EDIT.", "access"))

	for _, field := range fields {
		access := NewAccessor(field.Tag)
		if access == nil {
			continue
		}

		if access.Read {
			if field.Exported {
				panic("cannot export public field: " + field.Name)
			}
			generateGetter(f, pkgPath, structName, field)
		}

		if access.Write {
			if field.IsPointer {
				generateSetterPointer(f, pkgPath, structName, field)
			} else {
				generateSetter(f, pkgPath, structName, field)
			}
		}
	}

	return f.Save(out) // e.g. main_gen.go
}

func generateGetter(f *jen.File, pkgPath, structName string, field gen.StructField) {
	// Output:
	// func (e YourStruct) Name() string {
	// 	return e.name
	// }
	ptr := ""
	if field.IsPointer {
		ptr = "*"
	}

	shortName := gen.LowerFirst(structName)[:1]
	f.Func().Params(
		// (e YourStruct)
		Id(shortName).Id(structName),
	).Id(
		// Name
		gen.UpperCommonInitialism(field.Name),
	).
		Params().Op(ptr).
		Qual(gen.SkipCurrentPackagePath(pkgPath, field), field.FieldType).Block(
		Return(Id(shortName).Dot(field.Name)),
	).Line()
}

func generateSetter(f *jen.File, pkgPath, structName string, field gen.StructField) {
	// Output:
	// func (e *YourStruct) SetName(name string) *YourStruct {
	// 	e.name = name
	//  return e
	// }

	shortName := gen.LowerFirst(structName)[:1]
	f.Func().Params(
		Id(shortName).Op("*").Id(structName), // (e *YourStruct)
	).Id(
		fmt.Sprintf("Set%s", gen.UpperCommonInitialism(field.Name)), // SetName
	).
		Params(
			// name string
			Id(gen.LowerFirst(field.Name)).Qual(gen.SkipCurrentPackagePath(pkgPath, field), field.FieldType),
		).
		Op("*").Id(structName).
		Block(
			Id(shortName).Dot(field.Name).Op("=").Id(gen.LowerFirst(field.Name)),
			Return(Id(shortName)),
		).Line()
}

func generateSetterPointer(f *jen.File, pkgPath, structName string, field gen.StructField) {
	// Output:
	// func (e *YourStruct) SetName(name string, valid bool) *YourStruct {
	//   if valid {
	//     e.name = &name
	// 	 }
	//  return e
	// }

	// Avoid conflict in naming if the variable is already named "valid".
	validVar := "valid"
	if field.Name == validVar {
		validVar += "1"
	}

	shortName := gen.LowerFirst(structName)[:1]
	f.Func().Params(
		Id(shortName).Op("*").Id(structName), // (e *YourStruct)
	).Id(
		fmt.Sprintf("Set%s", gen.UpperCommonInitialism(field.Name)), // SetName
	).
		Params(
			// name string
			Id(gen.LowerFirst(field.Name)).Qual(gen.SkipCurrentPackagePath(pkgPath, field), field.FieldType),
			Id(validVar).Bool(),
		).
		Op("*").Id(structName).
		Block(
			If(Id(validVar)).Block(
				Id(shortName).Dot(field.Name).Op("=").Op("&").Id(gen.LowerFirst(field.Name)),
			),
			Return(Id(shortName)),
		).Line()
}

type Accessor struct {
	Read  bool
	Write bool
}

func NewAccessor(in string) *Accessor {
	matches := tagRe.FindStringSubmatch(in)
	if len(matches) == 0 {
		return nil
	}
	var a Accessor
	switch matches[1] {
	case
		"r,w":
		a.Read = true
		a.Write = true
	case "r":
		a.Read = true
	case "w":
		a.Write = true
	case "-":
	default:
		panic("invalid access tag format")
	}
	return &a
}
