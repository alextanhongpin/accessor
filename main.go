package main

import (
	"flag"
	"fmt"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/alextanhongpin/pkg/stringcase"
	"github.com/dave/jennifer/jen"
	. "github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

var (
	tagRe *regexp.Regexp
)

func init() {
	tagRe = regexp.MustCompile(`access:"([r,w]{1,3})"`)
}

// StructField for the example below.
//type Foo struct {
//  Name sql.NullString `json:"name" access:"r,w"`
//}
type StructField struct {
	Name string `example:"Name"`
	// Useful when the output directory doesn't match the existing ones.
	PkgPath   string `example:"github.com/alextanhongpin/go-codegen/test"`
	Exported  bool   `example:"true"`
	FieldType string `example:"NullString"`

	// When true, the FieldPkgPath is not empty.
	NamedField   bool   `example:"true"`
	FieldPkgPath string `example:"database/sql"`
	Tag          string `example:""`
}

func main() {
	structPtr := flag.String("type", "", "the target struct name")
	inPtr := flag.String("in", os.Getenv("GOFILE"), "the input file, defaults to the file with the go:generate comment")
	outPtr := flag.String("out", "", "the output directory")
	flag.Parse()

	in := fullPath(*inPtr)
	structNames := strings.Split(*structPtr, ",")
	for _, structName := range structNames {
		// When dealing with multiple structs, we need to generate multiple files.
		var out string
		if o := *outPtr; o == "" {
			out = in
		} else {
			out = fullPath(o)
		}
		fileName := stringcase.SnakeCase(structName) + ".go"
		genFileName := safeAddSuffixToFileName(fileName, "_gen")
		out = safeAddFileName(filepath.Dir(out), genFileName)

		pkg := loadPackage(packagePath(in)) // github.com/your-github-username/your-pkg.
		pkgName := pkg.Name                 // Specify the config packages.NeedName to get this value.

		obj := pkg.Types.Scope().Lookup(structName)
		if obj == nil {
			log.Fatalf("struct %s not found", structName)
		}

		// Check if it is a declared typed.
		if _, ok := obj.(*types.TypeName); !ok {
			log.Fatalf("%v is not a named type", obj)
		}

		// Check if the type is a struct.
		structType, ok := obj.Type().Underlying().(*types.Struct)
		if !ok {
			log.Fatalf("%v is not a struct", obj)
		}

		fields := extractFields(structType)
		if err := generateStructFromFields(pkgName, out, structName, fields); err != nil {
			log.Fatalln(err)
		}
		fmt.Printf("wrote file to %s\n", out)
	}
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedImports,
	}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		log.Fatalf("failed to load package: %v", err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}
	return pkgs[0]
}

func extractFields(structType *types.Struct) []StructField {
	fields := make([]StructField, structType.NumFields())
	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)
		tag := structType.Tag(i)

		var (
			name         = field.Name()
			pkgPath      = field.Pkg().Path()
			exported     = field.Exported()
			namedField   = false
			fieldPkgPath = ""
			fieldType    = ""
		)
		switch t := field.Type().(type) {
		case *types.Named:
			obj := t.Obj()
			fieldPkgPath = obj.Pkg().Path()
			fieldType = obj.Name()
			namedField = true
		default:
			fieldType = t.String()
			namedField = false
		}
		fields[i] = StructField{
			Name:         name,
			PkgPath:      pkgPath,
			Exported:     exported,
			FieldType:    fieldType,
			NamedField:   namedField,
			FieldPkgPath: fieldPkgPath,
			Tag:          tag,
		}
	}
	return fields
}

func generateStructFromFields(pkgName, out, structName string, fields []StructField) error {

	f := NewFile(pkgName) // e.g. main
	f.PackageComment(fmt.Sprintf("Code generated by %s, DO NOT EDIT.", "access"))

	for _, field := range fields {
		access := NewAccessor(field.Tag)
		if access == nil {
			continue
		}

		if access.Read {
			if field.Exported {
				panic("cannot export public field: " + field.Name)
			}

			generateGetter(f, structName, field)
		}
		if access.Write {
			generateSetter(f, structName, field)
		}
	}

	return f.Save(out) // e.g. main_gen.go
}

func generateGetter(f *jen.File, structName string, field StructField) {
	// Output:
	// func (e YourStruct) Name() string {
	// 	return e.name
	// }

	isCommonInitialisms := commonInitialisms[strings.ToUpper(field.Name)]
	var fieldName string
	if isCommonInitialisms {
		fieldName = strings.ToUpper(field.Name)
	} else {
		fieldName = upperFirst(field.Name)
	}

	shortName := lowerFirst(structName)[:1]
	f.Func().Params(
		// (e YourStruct)
		Id(shortName).Id(structName),
	).Id(
		// Name
		fieldName,
	).
		Params().
		Qual(field.FieldPkgPath, field.FieldType).Block(
		Return(Id(shortName).Dot(field.Name)),
	).Line()
}

func generateSetter(f *jen.File, structName string, field StructField) {
	// Output:
	// func (e YourStruct) SetName(name string) {
	// 	e.name = name
	// }

	isCommonInitialisms := commonInitialisms[strings.ToUpper(field.Name)]
	var fieldName string
	if isCommonInitialisms {
		fieldName = strings.ToUpper(field.Name)
	} else {
		fieldName = upperFirst(field.Name)
	}

	shortName := lowerFirst(structName)[:1]
	f.Func().Params(
		Id(shortName).Op("*").Id(structName), // (e *YourStruct)
	).Id(
		fmt.Sprintf("Set%s", fieldName), // SetName
	).
		Params(
			// name string
			Id(lowerFirst(field.Name)).Qual(field.FieldPkgPath, field.FieldType),
		).
		Block(
			Id(shortName).Dot(field.Name).Op("=").Id(lowerFirst(field.Name)),
		).Line()
}

type Accessor struct {
	Read  bool
	Write bool
}

func NewAccessor(in string) *Accessor {
	matches := tagRe.FindStringSubmatch(in)
	if len(matches) == 0 {
		return nil
	}
	var a Accessor
	switch matches[0] {
	case
		`access:"r,w"`,
		`access:"w,r"`:
		a.Read = true
		a.Write = true
	case `access:"r"`:
		a.Read = true
	case `access:"w"`:
		a.Write = true
	}
	return &a
}

func upperFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func lowerFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

// fullPath returns the full path to the package.
func fullPath(rel string) string {
	path, err := os.Getwd()
	if err != nil {
		log.Fatalf("failed to get package directory: %v", err)
	}
	path = filepath.Join(path, rel)
	return path
}

// packagePath returns the github package path.
func packagePath(path string) string {
	if ext := filepath.Ext(path); ext != "" {
		base := filepath.Base(path)
		path = path[:len(path)-len(base)]
	}
	if strings.HasSuffix(path, "/") {
		path = path[:len(path)-1]
	}
	idx := strings.Index(path, "github.com")
	return path[idx:]
}

// packageName returns the base package name.
func packageName(path string) string {
	return filepath.Base(packagePath(path))
}

// addSuffixToFileName adds a suffix to the filename, before the extension, to allow main.go -> main_gen.go
func addSuffixToFileName(path, suffix string) string {
	ext := filepath.Ext(path)
	path = path[:len(path)-len(ext)]
	return path + suffix + ext
}

// safeAddSuffixToFileName only adds the suffix if the user generated name does not already contains the suffix.
func safeAddSuffixToFileName(path, suffix string) string {
	if strings.Contains(path, suffix) {
		return path
	}
	return addSuffixToFileName(path, suffix)
}

func isFile(path string) bool {
	return filepath.Ext(path) != ""
}

func safeAddFileName(path, fileName string) string {
	if isFile(path) {
		return path
	}
	return filepath.Join(path, fileName)
}

// https://github.com/golang/lint/blob/83fdc39ff7b56453e3793356bcff3070b9b96445/lint.go#L770-L809
// commonInitialisms is a set of common initialisms.
// Only add entries that are highly unlikely to be non-initialisms.
// For instance, "ID" is fine (Freudian code is rare), but "AND" is not.
var commonInitialisms = map[string]bool{
	"ACL":   true,
	"API":   true,
	"ASCII": true,
	"CPU":   true,
	"CSS":   true,
	"DNS":   true,
	"EOF":   true,
	"GUID":  true,
	"HTML":  true,
	"HTTP":  true,
	"HTTPS": true,
	"ID":    true,
	"IP":    true,
	"JSON":  true,
	"LHS":   true,
	"QPS":   true,
	"RAM":   true,
	"RHS":   true,
	"RPC":   true,
	"SLA":   true,
	"SMTP":  true,
	"SQL":   true,
	"SSH":   true,
	"TCP":   true,
	"TLS":   true,
	"TTL":   true,
	"UDP":   true,
	"UI":    true,
	"UID":   true,
	"UUID":  true,
	"URI":   true,
	"URL":   true,
	"UTF8":  true,
	"VM":    true,
	"XML":   true,
	"XMPP":  true,
	"XSRF":  true,
	"XSS":   true,
}
